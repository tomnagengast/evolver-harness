/**
 * CLAUDE.md Injector
 *
 * Manages dynamic injection of experience-based context into CLAUDE.md files.
 * Provides safe backup/restore mechanisms and automatic cleanup.
 */

import * as fs from 'fs';
import * as path from 'path';
import { Principle, PrincipleScore, calculatePrincipleScore } from '../types.js';

/**
 * Configuration for CLAUDE.md injection
 */
export interface InjectorConfig {
  /** Path to CLAUDE.md file (default: ./CLAUDE.md) */
  claudeMdPath?: string;

  /** Path to backup file (default: ./CLAUDE.md.evolver-backup) */
  backupPath?: string;

  /** Include usage statistics in injected content */
  includeStats?: boolean;

  /** Maximum number of principles to inject */
  maxPrinciples?: number;

  /** Format style for principles */
  formatStyle?: 'compact' | 'detailed';

  /** Enable verbose logging */
  verbose?: boolean;
}

/**
 * Section markers for identifying injected content
 */
const EXPERIENCE_SECTION_START = '<!-- EVOLVER_EXPERIENCE_START -->';
const EXPERIENCE_SECTION_END = '<!-- EVOLVER_EXPERIENCE_END -->';
const EXPERIENCE_HEADING = '## Relevant Experience';

/**
 * Template for the experience section
 */
export const EXPERIENCE_SECTION_TEMPLATE = `
${EXPERIENCE_SECTION_START}
${EXPERIENCE_HEADING}

> This section contains principles retrieved from your experience base.
> These have been automatically selected based on the current task.

{principles}

---
*This section was automatically generated by the Evolver harness.*
*It will be removed at the end of the session.*
${EXPERIENCE_SECTION_END}
`.trim();

/**
 * ClaudeMdInjector manages dynamic content injection into CLAUDE.md files
 */
export class ClaudeMdInjector {
  private config: Required<InjectorConfig>;

  constructor(config: InjectorConfig = {}) {
    const claudeMdPath = config.claudeMdPath || path.join(process.cwd(), 'CLAUDE.md');
    this.config = {
      claudeMdPath,
      backupPath: config.backupPath || `${claudeMdPath}.evolver-backup`,
      includeStats: config.includeStats ?? true,
      maxPrinciples: config.maxPrinciples ?? 10,
      formatStyle: config.formatStyle ?? 'compact',
      verbose: config.verbose ?? false,
    };
  }

  /**
   * Add experience section to CLAUDE.md
   * Creates backup before modification
   */
  async addExperienceSection(principles: Principle[] | PrincipleScore[]): Promise<void> {
    if (this.config.verbose) {
      console.error(`[Injector] Adding experience section with ${principles.length} principles`);
    }

    // Create backup first
    await this.backup();

    // Read current content
    let content = '';
    if (fs.existsSync(this.config.claudeMdPath)) {
      content = fs.readFileSync(this.config.claudeMdPath, 'utf-8');
    } else {
      // Create minimal CLAUDE.md if it doesn't exist
      content = '# CLAUDE.md\n\nProject-specific instructions for Claude.\n';
    }

    // Remove existing experience section if present
    content = this.removeExperienceSection(content);

    // Format principles
    const principlesText = this.formatPrinciples(principles.slice(0, this.config.maxPrinciples));

    // Build experience section
    const experienceSection = EXPERIENCE_SECTION_TEMPLATE.replace('{principles}', principlesText);

    // Inject at the end of the file
    const injectedContent = `${content.trimEnd()}\n\n${experienceSection}\n`;

    // Write back
    fs.writeFileSync(this.config.claudeMdPath, injectedContent, 'utf-8');

    if (this.config.verbose) {
      console.error(`[Injector] Experience section added to ${this.config.claudeMdPath}`);
    }
  }

  /**
   * Remove experience section from CLAUDE.md
   */
  async removeExperienceSection(): Promise<void> {
    if (this.config.verbose) {
      console.error('[Injector] Removing experience section');
    }

    if (!fs.existsSync(this.config.claudeMdPath)) {
      if (this.config.verbose) {
        console.error('[Injector] CLAUDE.md does not exist, nothing to remove');
      }
      return;
    }

    const content = fs.readFileSync(this.config.claudeMdPath, 'utf-8');
    const cleaned = this.removeExperienceSection(content);

    fs.writeFileSync(this.config.claudeMdPath, cleaned, 'utf-8');

    if (this.config.verbose) {
      console.error('[Injector] Experience section removed');
    }
  }

  /**
   * Create backup of CLAUDE.md
   */
  async backup(): Promise<void> {
    if (!fs.existsSync(this.config.claudeMdPath)) {
      if (this.config.verbose) {
        console.error('[Injector] No CLAUDE.md to backup');
      }
      return;
    }

    const content = fs.readFileSync(this.config.claudeMdPath, 'utf-8');
    fs.writeFileSync(this.config.backupPath, content, 'utf-8');

    if (this.config.verbose) {
      console.error(`[Injector] Backup created at ${this.config.backupPath}`);
    }
  }

  /**
   * Restore CLAUDE.md from backup
   */
  async restore(): Promise<void> {
    if (!fs.existsSync(this.config.backupPath)) {
      if (this.config.verbose) {
        console.error('[Injector] No backup to restore');
      }
      return;
    }

    const content = fs.readFileSync(this.config.backupPath, 'utf-8');
    fs.writeFileSync(this.config.claudeMdPath, content, 'utf-8');

    // Clean up backup
    fs.unlinkSync(this.config.backupPath);

    if (this.config.verbose) {
      console.error('[Injector] CLAUDE.md restored from backup');
    }
  }

  /**
   * Check if backup exists
   */
  hasBackup(): boolean {
    return fs.existsSync(this.config.backupPath);
  }

  /**
   * Check if experience section is present
   */
  hasExperienceSection(): boolean {
    if (!fs.existsSync(this.config.claudeMdPath)) {
      return false;
    }

    const content = fs.readFileSync(this.config.claudeMdPath, 'utf-8');
    return content.includes(EXPERIENCE_SECTION_START);
  }

  /**
   * Get current CLAUDE.md path
   */
  getClaudeMdPath(): string {
    return this.config.claudeMdPath;
  }

  /**
   * Get backup path
   */
  getBackupPath(): string {
    return this.config.backupPath;
  }

  // Private helper methods

  /**
   * Remove experience section from content string
   */
  private removeExperienceSection(content: string): string {
    const startIndex = content.indexOf(EXPERIENCE_SECTION_START);

    if (startIndex === -1) {
      return content;
    }

    const endIndex = content.indexOf(EXPERIENCE_SECTION_END, startIndex);

    if (endIndex === -1) {
      // Malformed section, remove from start marker to end
      return content.substring(0, startIndex).trimEnd();
    }

    // Remove from start marker to end marker (inclusive)
    const before = content.substring(0, startIndex).trimEnd();
    const after = content.substring(endIndex + EXPERIENCE_SECTION_END.length).trimStart();

    return before + (after ? '\n\n' + after : '') + '\n';
  }

  /**
   * Format principles for injection
   */
  private formatPrinciples(principles: Principle[] | PrincipleScore[]): string {
    if (principles.length === 0) {
      return 'No relevant principles found for this task.';
    }

    const isPrincipleScores = this.isPrincipleScoreArray(principles);
    const lines: string[] = [];

    for (let i = 0; i < principles.length; i++) {
      const item = principles[i];
      const principle = isPrincipleScores ? item.principle : item;
      const score = isPrincipleScores ? item.score : calculatePrincipleScore(principle);

      if (this.config.formatStyle === 'compact') {
        lines.push(this.formatPrincipleCompact(principle, score, i + 1));
      } else {
        lines.push(this.formatPrincipleDetailed(principle, score, i + 1));
      }
    }

    return lines.join('\n\n');
  }

  /**
   * Format a single principle in compact style
   */
  private formatPrincipleCompact(principle: Principle, score: number, index: number): string {
    const confidence = score > 0.8 ? 'HIGH' : score > 0.6 ? 'MEDIUM' : 'LOW';
    const tags = principle.tags.length > 0 ? ` (${principle.tags.join(', ')})` : '';

    let output = `**${index}.** ${principle.text}${tags}`;

    if (this.config.includeStats) {
      output += `\n   *Confidence: ${confidence} - ${(score * 100).toFixed(0)}% (${principle.success_count}/${principle.use_count} success rate)*`;
    }

    return output;
  }

  /**
   * Format a single principle in detailed style
   */
  private formatPrincipleDetailed(principle: Principle, score: number, index: number): string {
    const confidence = score > 0.8 ? 'HIGH' : score > 0.6 ? 'MEDIUM' : 'LOW';
    const lines: string[] = [];

    lines.push(`### ${index}. ${principle.text.substring(0, 80)}${principle.text.length > 80 ? '...' : ''}`);
    lines.push('');
    lines.push(principle.text);

    if (principle.tags.length > 0) {
      lines.push('');
      lines.push(`**Tags:** ${principle.tags.join(', ')}`);
    }

    if (this.config.includeStats) {
      lines.push('');
      lines.push(
        `**Confidence:** ${confidence} (${(score * 100).toFixed(1)}% - ${principle.success_count} successes / ${principle.use_count} uses)`
      );
    }

    if (principle.triples.length > 0) {
      lines.push('');
      lines.push('**Context:**');
      for (const triple of principle.triples.slice(0, 3)) {
        lines.push(`- ${triple.subject} → ${triple.relation} → ${triple.object}`);
      }
    }

    return lines.join('\n');
  }

  /**
   * Type guard for PrincipleScore arrays
   */
  private isPrincipleScoreArray(
    principles: Principle[] | PrincipleScore[]
  ): principles is PrincipleScore[] {
    return principles.length > 0 && 'score' in principles[0] && 'principle' in principles[0];
  }
}

/**
 * Convenience function to inject principles into CLAUDE.md
 */
export async function injectPrinciples(
  principles: Principle[] | PrincipleScore[],
  config?: InjectorConfig
): Promise<void> {
  const injector = new ClaudeMdInjector(config);
  await injector.addExperienceSection(principles);
}

/**
 * Convenience function to remove experience section from CLAUDE.md
 */
export async function removeExperienceSection(config?: InjectorConfig): Promise<void> {
  const injector = new ClaudeMdInjector(config);
  await injector.removeExperienceSection();
}

/**
 * Convenience function to restore CLAUDE.md from backup
 */
export async function restoreClaudeMd(config?: InjectorConfig): Promise<void> {
  const injector = new ClaudeMdInjector(config);
  await injector.restore();
}

